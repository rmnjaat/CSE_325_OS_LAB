static_cast<int>()

auto ko declare ke timee inilise krna pde ga;

short int 2
int 4
long int 8
long long int 8
string_view  :: The output would be the same as above, but no more copies of the string “Hello !!, GeeksforGeeks” are created in the Memory.

bool  1
char 1
float 4
double 8
long double 16

setprecision(3) 2.09

double /0   inf
double 0/0  nan



in case of double value  Std::hex ,std::oct  etc will not affect ift will sow only double value


SHort int +Short int return 4 bit size
char + char also return 4 bit size


To do calculation at compile time we can use type constexpr int,char etc..

bitset library is used for bitset<4>(v1) v1 in binary with 4 bit


We can initlize inside if(int speed{10};true);
no matter condition is true or false, Variable will inalize
scope of speed is inside if and else onle not outside them


int *ptr=NULL;
if(!ptr){true if ptr is null};


void *p;
*(int*(p)); deref and type cast void pointer.


However, the problem with this code is that the num variable is a local variable in the getPointer() function. Once the function returns, the memory allocated for num is deallocated, and the pointer ptr becomes a dangling pointer pointing to an invalid memory location.


static member not have this pointer.





Use size_t : a representation of some unsigned int for positive numbers [sizes]

Size of size_t is 8



lopp can have multiple declaration or condition with , seprated

for (size_t i{0} , x {5}, y{22} ; y > 15 ; ++i , x+=5 , y-=1)


array inside function size gives 8 because it's recieve a pointer;




sizeof (int)    gives size of any datatype

In case  of char string we can print entire string by its name only

const char * message {"Hello World!"};
message=Hello World!
*message=H

n C++, when you declare a string literal (e.g., "Hello"), it is stored as a constant array of characters. This means that the memory location where the string literal is stored cannot be modified.

When you assign a string literal to a non-const pointer, such as char*, the compiler allows it, but it may generate a warning because it violates the const correctness principle. Modifying a string literal through a non-const pointer can lead to undefined behavior.


int scores[10] {11,12,13,14,15,16,17,18,19,20};    
    int * p_score { scores};
    size of will not work for p_scores
    
     std::cout << "*scores : " << *scores << std::endl;    //11
    std::cout << "scores[0] : " << scores[0] << std::endl;  //11
    std::cout << "*p_score : " << *p_score << std::endl;//11
	std::cout << "p_score[0] : " << p_score[0] << std::endl;//11


	swapping two array 
	
    int * temp{nullptr};

    temp = p_arr1;
    p_arr1 = p_arr0;
    p_arr0 = temp;
    
    
    
std::optional<int> var    in <optional > library
	used for variable that may or may not have any  value
	
	
static var this variable life time goes  beyound function;

inline int fun()




---------------OOps-------------------
destructor is called automatically  for static member
	 Dog *dog5=new Dog("doggy 5","Bolly",8);
    		delete dog5;
    		
    		The base class members cannot be directly assigned using initializer list. We should call the base class constructor in order to initialize base class members.
    		
    		
    		Explanation: This is a typical example of diamond problem of multiple inheritance. Here the base class member ‘a’ is inherited through both Derived1 and Derived2. So there are two copies of ‘a’ in DerivedDerived which makes the statement “cout << a;" ambiguous.
    		
    		
    		One more thing, as we are using virtual before base class, there will be only one copy of base class in multiple inheritance.	
    		
    		Output will be 13571358 as 1357 (for D d1) and as 1358 (for D d(d1))……reason is that ……during inheritance we need to explicitly call copy constructor of base class otherwise only default constructor of base class is called. 
    		

    	
 abstract class : abstarct clss can only have pointer not object
    
